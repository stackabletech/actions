---
name: Run Integration Test
description: |
  This action runs Stackable Operator integration tests on various platforms and
  Kubernetes distributions.
inputs:
  # Test inputs
  test-mode:
    description: Interu test mode to run in
  test-mode-input:
    description: The Interu profile or runner to be used based on the test-mode
  test-suite:
    description: The Beku test-suite to run
  test:
    description: Matching Beku tests to run

  # Tokens
  replicated-api-token:
    description: Replicated API token

  # Tool versions
  interu-version:
    description: Version of interu
    # See https://github.com/stackabletech/actions/releases for latest version
    default: 0.2.0
  beku-version:
    description: Version of beku
    # See https://github.com/stackabletech/beku.py/releases for latest version
    default: 0.0.10
  kubectl-version:
    description: Version of kubectl
    # See https://dl.k8s.io/release/stable.txt for latest version
    default: v1.33.4
  kuttl-version:
    description: Version of kubectl-kuttl
    # See https://github.com/kudobuilder/kuttl/releases for latest version
    default: 0.22.0
  helm-version:
    description: Version of helm
    # See https://github.com/helm/helm/releases for latest version
    default: v3.18.6
  stackablectl-version:
    description: Version of stackablectl
    # See https://github.com/stackabletech/stackable-cockpit/releases for latest version
    default: 1.1.0
outputs:
  start-time:
    description: The date and time this integration test was started.
    value: ${{ steps.start-time.outputs.START_TIME }}
  end-time:
    description: The date and time this integration test finished.
    value: ${{ steps.end-time.outputs.END_TIME }}
  health:
    description: The health of this integration test over the last few tries.
    value: ${{ steps.health.outputs.HEALTH }}
  failed-tests:
    description: The (potentially empty) list of failed tests
    value: ${{ steps.failed-tests.outputs.FAILED_TESTS }}
runs:
  using: composite
  steps:
    - name: Install interu
      env:
        INTERU_VERSION: ${{ inputs.interu-version }}
        GITHUB_DEBUG: ${{ runner.debug }}
      shell: bash
      run: "$GITHUB_ACTION_PATH/../.scripts/actions/install_interu.sh"

    - name: Extract Test and Instance Configuration
      env:
        TEST_MODE_INPUT: ${{ inputs.test-mode-input }}
        TEST_SUITE: ${{ inputs.test-suite }}
        TEST_MODE: ${{ inputs.test-mode }}
        TEST: ${{ inputs.test }}
        GITHUB_DEBUG: ${{ runner.debug }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_RUN_ID: ${{ github.run_id }}"
      shell: bash
      run: |
        set -euo pipefail
        [ -n "$GITHUB_DEBUG" ] && set -x

        # Generate the cluster name
        echo "KUBERNETES_CLUSTER_NAME=integration-test-${GITHUB_REPOSITORY}-${GITHUB_RUN_ID}" | tee -a "$GITHUB_ENV"

        # Run interu to expand parameters into GITHUB_ENV
        if [ "$TEST_MODE" == "profile" ]; then
          [ -n "${TEST_SUITE:-}" ] && echo "::warning::The test-suite input is ignored, because a profile is selected."
          [ -n "${TEST:-}" ] && echo "::warning::The test input is ignored, because a profile is selected."

          interu --instances "$GITHUB_ACTION_PATH/instances.yaml" profile "$TEST_MODE_INPUT" --check-test-definitions --output "$GITHUB_ENV"
        else
          [ -n "${TEST_SUITE:-}" ] && ARGS+=" --test-suite $TEST_SUITE"
          [ -n "${TEST:-}" ] && ARGS+=" --test $TEST"

          interu --instances "$GITHUB_ACTION_PATH/instances.yaml" custom "$TEST_MODE_INPUT" ${ARGS:-} --output "$GITHUB_ENV"
        fi

    # Install all tools BEFORE creating the cluster, because if some of the tools fail to download
    # and are therefore not available, there is no need to create the cluster or run the tests,
    # because the tests can never run in the first place.
    - name: Install kubectl, kubectl-kuttl, and helm
      env:
        KUBECTL_VERSION: ${{ inputs.kubectl-version }}
        KUTTL_VERSION: ${{ inputs.kuttl-version }}
        HELM_VERSION: ${{ inputs.helm-version }}
        GITHUB_DEBUG: ${{ runner.debug }}
      shell: bash
      run: |
        "$GITHUB_ACTION_PATH/../.scripts/actions/install_kubectl.sh"
        "$GITHUB_ACTION_PATH/../.scripts/actions/install_kubectl_kuttl.sh"
        "$GITHUB_ACTION_PATH/../.scripts/actions/install_helm.sh"

    # Python3 is already installed, if we ever need to specify the version, we can use the
    # setup-python action.
    # See https://github.com/actions/runner-images/blob/main/images/ubuntu/scripts/build/install-python.sh
    #
    # mikefarah/yq is already installed on the runner
    # See https://github.com/actions/runner-images/blob/main/images/ubuntu/scripts/build/install-yq.sh
    - name: Install stackablectl
      env:
        STACKABLECTL_VERSION: ${{ inputs.stackablectl-version }}
        BEKU_VERSION: ${{ inputs.beku-version }}
        GITHUB_DEBUG: ${{ runner.debug }}
      shell: bash
      run: "$GITHUB_ACTION_PATH/../.scripts/actions/install_stackablectl.sh"

    - name: Install beku
      env:
        BEKU_VERSION: ${{ inputs.beku-version }}
        GITHUB_DEBUG: ${{ runner.debug }}
      shell: bash
      run: |
        set -euo pipefail
        [ -n "$GITHUB_DEBUG" ] && set -x

        pip install "beku-stackabletech==$BEKU_VERSION"

    - name: Install apt packages
      shell: bash
      run: |
        set -euo pipefail

        sudo apt update
        sudo apt install -y \
          gettext-base

    - name: Prepare Replicated Cluster
      id: prepare-replicated-cluster
      uses: replicatedhq/replicated-actions/create-cluster@49b440dabd7e0e868cbbabda5cfc0d8332a279fa # v1.19.0
      with:
        # See: https://github.com/replicatedhq/replicated-actions/tree/main/create-cluster#inputs
        api-token: ${{ inputs.replicated-api-token }}
        cluster-name: ${{ env.KUBERNETES_CLUSTER_NAME }}
        kubernetes-distribution: ${{ env.INTERU_KUBERNETES_DISTRIBUTION }}
        kubernetes-version: ${{ env.INTERU_KUBERNETES_VERSION }}
        ttl: ${{ env.INTERU_CLUSTER_TTL }}
        node-groups: ${{ env.INTERU_NODE_GROUPS }}
        # FIXME (@Techassi): Add test-suite and test here
        tags: |
          - key: kubernetes-distribution
            value: ${{ env.INTERU_KUBERNETES_DISTRIBUTION }}
          - key: triggered-by
            value: ${{ github.triggering_actor }}
          - key: test-parallelism
            value: "${{ env.BEKU_TEST_PARALLELISM }}"

    - name: Set Replicated kubeconfig
      env:
        KUBECONFIG: ${{ steps.prepare-replicated-cluster.outputs.cluster-kubeconfig }}
      shell: bash
      run: |
        set -euo pipefail
        mkdir ~/.kube
        echo "$KUBECONFIG" > ~/.kube/config

    - name: Extract Operator Name
      env:
        REPOSITORY: ${{ github.repository }}
      shell: bash
      run: |
        set -euo pipefail

        OPERATOR_NAME=$(echo "$REPOSITORY" | cut -d / -f 2 | sed 's/-operator//g')
        echo "OPERATOR_NAME=$OPERATOR_NAME" | tee -a "$GITHUB_ENV"

    - name: Install OpenTelemetry Operator
      shell: bash
      run: |
        set -euo pipefail

        echo "::group::kubectl apply"
        kubectl kustomize --enable-helm "${GITHUB_ACTION_PATH}/kustomize/bases/opentelemetry-operator" | kubectl apply -f -
        kubectl -n opentelemetry-operator wait --for condition=Progressing deploy/opentelemetry-operator --timeout=300s
        kubectl -n opentelemetry-operator wait --for condition=Available deploy/opentelemetry-operator --timeout=300s
        kubectl -n opentelemetry-operator get pods
        echo "::endgroup::"

    - name: Apply OpenTelemetry Collectors configurations
      shell: bash
      env:
        GITHUB_TRIGGERED_BY: ${{ github.triggering_actor }}
      run: |
        set -euo pipefail

        echo "::group::get info"
        INTEGRATION_TEST_INFO="${GITHUB_ACTION_PATH}/kustomize/overlays/replicated/integration-test-info.env"
        echo "KUBERNETES_CLUSTER_NAME=${KUBERNETES_CLUSTER_NAME}" | tee -a "$INTEGRATION_TEST_INFO"
        echo "KUBERNETES_DISTRIBUTION=${INTERU_KUBERNETES_DISTRIBUTION}" | tee -a "$INTEGRATION_TEST_INFO"
        echo "KUBERNETES_VERSION=${INTERU_KUBERNETES_VERSION}" | tee -a "$INTEGRATION_TEST_INFO"
        echo "TRIGGERED_BY=${GITHUB_TRIGGERED_BY}" | tee -a "$INTEGRATION_TEST_INFO"
        echo "::endgroup::"

        echo "::group::kubectl apply"
        kubectl apply -k "${GITHUB_ACTION_PATH}/kustomize/overlays/replicated"
        echo "Waiting a few seconds for the operator to create the deployment" && sleep 5
        kubectl -n opentelemetry-operator wait --for condition=Progressing deploy/replicated-kubernetes-events-collector --timeout=300s
        kubectl -n opentelemetry-operator wait --for condition=Available deploy/replicated-kubernetes-events-collector --timeout=300s
        kubectl -n opentelemetry-operator rollout status ds replicated-container-log-scrape-collector --timeout=300s
        echo "::endgroup::"
        echo "::group::kubectl get"
        kubectl -n opentelemetry-operator get opentelemetrycollectors
        kubectl -n opentelemetry-operator get pods
        echo "::endgroup::"

    - name: Record Test Start Time
      id: start-time
      shell: bash
      run: |
        echo "START_TIME=$(date +'%Y-%m-%dT%H:%M:%S')" | tee -a "$GITHUB_OUTPUT"

    - name: Run Integration Test
      id: integration-test
      env:
        REF_NAME: ${{ github.ref_name }}
        GH_TOKEN: ${{ github.token }}
      shell: bash
      run: |
        set -euo pipefail

        OPERATOR_VERSION=$("$GITHUB_ACTION_PATH/../.scripts/actions/get_operator_version.sh" "$REF_NAME")
        python ./scripts/run-tests --skip-tests --operator "$OPERATOR_NAME=$OPERATOR_VERSION" | tee -a test-output.log

        [ -n "${BEKU_TEST_SUITE:-}" ] && ARGS+=" --test-suite $BEKU_TEST_SUITE"
        [ -n "${BEKU_TEST:-}" ] && ARGS+=" --test $BEKU_TEST"

        python ./scripts/run-tests --skip-release --log-level debug --parallel "$BEKU_TEST_PARALLELISM" ${ARGS:-} | tee -a test-output.log

    - name: Record Test End Time
      id: end-time
      if: always()
      shell: bash
      run: |
        echo "END_TIME=$(date +'%Y-%m-%dT%H:%M:%S')" | tee -a "$GITHUB_OUTPUT"

    - name: Destroy Replicated Cluster
      if: always()
      # If the creation of the cluster failed, we don't want to error and abort
      continue-on-error: true
      uses: replicatedhq/replicated-actions/remove-cluster@49b440dabd7e0e868cbbabda5cfc0d8332a279fa # v1.19.0
      with:
        # See: https://github.com/replicatedhq/replicated-actions/tree/main/remove-cluster#inputs
        api-token: ${{ inputs.replicated-api-token }}
        cluster-id: ${{ steps.prepare-replicated-cluster.outputs.cluster-id }}

    - name: Extract Failed Tests
      id: failed-tests
      # The success() function is automatically used if no other status function is used.
      # See https://docs.github.com/en/actions/reference/workflows-and-actions/expressions#failure-with-conditions
      if: failure() && steps.integration-test.conclusion == 'failure'
      shell: bash
      run: |
        # Only look at the last 200 lines of test output which should be more than enough to capture all test results
        FAILED_TESTS=$(tail --lines 200 test-output.log | grep -E '\s{8}--- FAIL:' | sed -e 's|^.*kuttl/harness/||')
        echo "FAILED_TESTS<<EOF\n$FAILED_TESTS\nEOF" | tee -a "$GITHUB_OUTPUT"

    - name: Calculate Health
      if: always()
      id: health
      env:
        INTEGRATION_TEST_CONCLUSION: ${{ steps.integration-test.conclusion }}
        WORKFLOW_NAME: "Integration Test"
        GH_TOKEN: ${{ github.token }}
        LAST_TRIES_LIMIT: "4"
      shell: bash
      run: |
        set -euo pipefail

        # First, we retrieve the number of successes of the last (currently) 4 runs. Afterwards we
        # add 1 to the number of successes if this run succeeded. This ultimately represents the
        # number of successes in the last 5 runs, similar to what Jenkins does. This score is then
        # turned into an appropriate "weather" emoji and provided as an output to follow-up steps.
        LAST_RUNS=$(gh run list --limit "$LAST_TRIES_LIMIT" --workflow "$WORKFLOW_NAME" --json conclusion)
        SUCCESSES=$(echo $LAST_RUNS | jq '[.[] | select(.conclusion == "success")] | length')
        export LAST_TRIES_TOTAL=$(echo $LAST_RUNS | jq 'length')

        [ "$INTEGRATION_TEST_CONCLUSION" == "success" ] && SUCCESSES=$(echo "$SUCCESSES+1" | bc)
        export SUCCESSES="$SUCCESSES"

        echo "HEALTH=$(cat "${GITHUB_ACTION_PATH}/health" | envsubst | bc)" | tee -a "$GITHUB_OUTPUT"
