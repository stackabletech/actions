---
name: Run Integration Test
description: |
  This action runs Stackable Operator integration tests on various platforms and
  Kubernetes distributions.
inputs:
  # Test inputs
  test-mode:
    description: Interu test mode to run in
  test-mode-input:
    description: The Interu profile or runner to be used based on the test-mode
  test-suite:
    description: The Beku test-suite to run
  test:
    description: Matching Beku tests to run

  # Tokens
  replicated-api-token:
    description: Replicated API token

  # Tool versions
  interu-version:
    description: Version of interu
    default: 0.2.0-rc.1
  beku-version:
    description: Version of beku
    default: 0.0.10
  kuttl-version:
    description: Version of kubectl-kuttl
    default: 0.22.0
  stackablectl-version:
    description: Version of stackablectl
    default: 1.1.0
outputs:
  start-time:
    description: The date and time this integration test was started.
    value: ${{ steps.start-time.outputs.START_TIME }}
  end-time:
    description: The date and time this integration test finished.
    value: ${{ steps.end-time.outputs.END_TIME }}
  health:
    description: The health of this integration test over the last few tries.
    value: ${{ steps.health.outputs.HEALTH }}
runs:
  using: composite
  steps:
    - name: Extract Test and Instance Configuration
      env:
        TEST_MODE_INPUT: ${{ inputs.test-mode-input }}
        TEST_SUITE: ${{ inputs.test-suite }}
        TEST_MODE: ${{ inputs.test-mode }}
        TEST: ${{ inputs.test }}
        INTERU_VERSION: ${{ inputs.interu-version }}
        GITHUB_DEBUG: ${{ runner.debug }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_RUN_ID: ${{ github.run_id }}"
      shell: bash
      run: |
        set -euo pipefail
        [ -n "$GITHUB_DEBUG" ] && set -x

        # Download interu
        curl -fsSL -o /tmp/interu "https://github.com/stackabletech/actions/releases/download/interu-$INTERU_VERSION/interu-x86_64-unknown-linux-gnu"
        sudo install -m 755 -t /usr/local/bin /tmp/interu

        # Generate the cluster name
        echo "KUBERNETES_CLUSTER_NAME=integration-test-${GITHUB_REPOSITORY}-${GITHUB_RUN_ID}" | tee -a "$GITHUB_ENV"

        # Run interu to expand parameters into GITHUB_ENV
        if [ "$TEST_MODE" == "profile" ]; then
          [ -n "${TEST_SUITE:-}" ] && echo "::warning::The test-suite input is ignored, because a profile is selected."
          [ -n "${TEST:-}" ] && echo "::warning::The test input is ignored, because a profile is selected."

          interu --instances "$GITHUB_ACTION_PATH/instances.yaml" profile "$TEST_MODE_INPUT" --check-test-definitions --output "$GITHUB_ENV"
        else
          [ -n "${TEST_SUITE:-}" ] && ARGS+=" --test-suite $TEST_SUITE"
          [ -n "${TEST:-}" ] && ARGS+=" --test $TEST"

          interu --instances "$GITHUB_ACTION_PATH/instances.yaml" custom "$TEST_MODE_INPUT" ${ARGS:-} --output "$GITHUB_ENV"
        fi

    # Install all tools BEFORE creating the cluster, because if some of the tools fail to download
    # and are therefore not available, there is no need to create the cluster or run the tests,
    # because the tests can never run in the first place.

    # We don't need to install kubectl, kind or helm because it is already part of the installed
    # tools of the runner image.
    # See https://github.com/actions/runner-images/blob/main/images/ubuntu/scripts/build/install-kubernetes-tools.sh
    - name: Install kubectl-kuttl
      env:
        KUTTL_VERSION: ${{ inputs.kuttl-version }}
      shell: bash
      run: |
        set -euo pipefail

        curl -fsSL -o /tmp/kubectl-kuttl "https://github.com/kudobuilder/kuttl/releases/download/v$KUTTL_VERSION/kubectl-kuttl_${KUTTL_VERSION}_linux_x86_64"
        sudo install -m 755 -t /usr/local/bin /tmp/kubectl-kuttl

    # Python3 is already installed, if we ever need to specify the version, we can use the
    # setup-python action.
    # See https://github.com/actions/runner-images/blob/main/images/ubuntu/scripts/build/install-python.sh
    - name: Install beku
      env:
        BEKU_VERSION: ${{ inputs.beku-version }}
      shell: bash
      run: |
        set -euo pipefail
        pip install "beku-stackabletech==$BEKU_VERSION"

    # mikefarah/yq is already installed on the runner
    # See https://github.com/actions/runner-images/blob/main/images/ubuntu/scripts/build/install-yq.sh

    - name: Install stackablectl
      env:
        STACKABLECTL_VERSION: ${{ inputs.stackablectl-version }}
      shell: bash
      run: |
        set -euo pipefail

        curl -fsSL -o /tmp/stackablectl "https://github.com/stackabletech/stackable-cockpit/releases/download/stackablectl-$STACKABLECTL_VERSION/stackablectl-x86_64-unknown-linux-gnu"
        sudo install -m 755 -t /usr/local/bin /tmp/stackablectl

    - name: Install apt packages
      shell: bash
      run: |
        set -euo pipefail

        sudo apt update
        sudo apt install -y \
          gettext-base

    - name: Prepare Replicated Cluster
      id: prepare-replicated-cluster
      uses: replicatedhq/replicated-actions/create-cluster@49b440dabd7e0e868cbbabda5cfc0d8332a279fa # v1.19.0
      with:
        # See: https://github.com/replicatedhq/replicated-actions/tree/main/create-cluster#inputs
        api-token: ${{ inputs.replicated-api-token }}
        cluster-name: ${{ env.KUBERNETES_CLUSTER_NAME }}
        kubernetes-distribution: ${{ env.INTERU_KUBERNETES_DISTRIBUTION }}
        kubernetes-version: ${{ env.INTERU_KUBERNETES_VERSION }}
        ttl: ${{ env.INTERU_CLUSTER_TTL }}
        node-groups: ${{ env.INTERU_NODE_GROUPS }}
        # FIXME (@Techassi): Add test-suite and test here
        tags: |
          - key: kubernetes-distribution
            value: ${{ env.INTERU_KUBERNETES_DISTRIBUTION }}
          - key: triggered-by
            value: ${{ github.triggering_actor }}
          - key: test-parallelism
            value: "${{ env.BEKU_TEST_PARALLELISM }}"

    - name: Set Replicated kubeconfig
      env:
        KUBECONFIG: ${{ steps.prepare-replicated-cluster.outputs.cluster-kubeconfig }}
      shell: bash
      run: |
        set -euo pipefail
        mkdir ~/.kube
        echo "$KUBECONFIG" > ~/.kube/config

    - name: Extract Operator Name
      env:
        REPOSITORY: ${{ github.repository }}
      shell: bash
      run: |
        set -euo pipefail

        OPERATOR_NAME=$(echo "$REPOSITORY" | cut -d / -f 2 | sed 's/-operator//g')
        echo "OPERATOR_NAME=$OPERATOR_NAME" | tee -a "$GITHUB_ENV"

    - name: Install OpenTelemetry Operator
      shell: bash
      run: |
        set -euo pipefail

        echo "::group::kubectl apply"
        kubectl kustomize --enable-helm "${GITHUB_ACTION_PATH}/kustomize/bases/opentelemetry-operator" | kubectl apply -f -
        kubectl -n opentelemetry-operator wait --for condition=Progressing deploy/opentelemetry-operator --timeout=300s
        kubectl -n opentelemetry-operator wait --for condition=Available deploy/opentelemetry-operator --timeout=300s
        kubectl -n opentelemetry-operator get pods
        echo "::endgroup::"

    - name: Apply OpenTelemetry Collectors configurations
      shell: bash
      env:
        GITHUB_TRIGGERED_BY: ${{ github.triggering_actor }}
      run: |
        set -euo pipefail

        echo "::group::get info"
        INTEGRATION_TEST_INFO="${GITHUB_ACTION_PATH}/kustomize/overlays/replicated/integration-test-info.env"
        echo "KUBERNETES_CLUSTER_NAME=${KUBERNETES_CLUSTER_NAME}" | tee -a "$INTEGRATION_TEST_INFO"
        echo "TRIGGERED_BY=${GITHUB_TRIGGERED_BY}" | tee -a "$INTEGRATION_TEST_INFO"
        echo "::endgroup::"

        echo "::group::kubectl apply"
        kubectl apply -k "${GITHUB_ACTION_PATH}/kustomize/overlays/replicated"
        echo "Waiting a few seconds for the operator to create the deployment" && sleep 5
        kubectl -n opentelemetry-operator wait --for condition=Progressing deploy/replicated-kubernetes-events-collector --timeout=300s
        kubectl -n opentelemetry-operator wait --for condition=Available deploy/replicated-kubernetes-events-collector --timeout=300s
        kubectl -n opentelemetry-operator rollout status ds replicated-container-log-scrape-collector --timeout=300s
        echo "::endgroup::"
        echo "::group::kubectl get"
        kubectl -n opentelemetry-operator get opentelemetrycollectors
        kubectl -n opentelemetry-operator get pods
        echo "::endgroup::"

    - name: Record Test Start Time
      id: start-time
      shell: bash
      run: |
        echo "START_TIME=$(date +'%Y-%m-%dT%H:%M:%S')" | tee -a "$GITHUB_OUTPUT"

    - name: Run Integration Test
      id: integration-test
      env:
        REF_NAME: ${{ github.ref_name }}
        GH_TOKEN: ${{ github.token }}
      shell: bash
      run: |
        set -euo pipefail

        OPERATOR_VERSION=$("$GITHUB_ACTION_PATH/../.scripts/actions/get_operator_version.sh" "$REF_NAME")
        python ./scripts/run-tests --skip-tests --operator "$OPERATOR_NAME=$OPERATOR_VERSION"

        [ -n "${BEKU_TEST_SUITE:-}" ] && ARGS+=" --test-suite $BEKU_TEST_SUITE"
        [ -n "${BEKU_TEST:-}" ] && ARGS+=" --test $BEKU_TEST"

        python ./scripts/run-tests --skip-release --log-level debug --parallel "$BEKU_TEST_PARALLELISM" ${ARGS:-}

    - name: Record Test End Time
      id: end-time
      if: always()
      shell: bash
      run: |
        echo "END_TIME=$(date +'%Y-%m-%dT%H:%M:%S')" | tee -a "$GITHUB_OUTPUT"

    - name: Destroy Replicated Cluster
      if: always()
      # If the creation of the cluster failed, we don't want to error and abort
      continue-on-error: true
      uses: replicatedhq/replicated-actions/remove-cluster@49b440dabd7e0e868cbbabda5cfc0d8332a279fa # v1.19.0
      with:
        # See: https://github.com/replicatedhq/replicated-actions/tree/main/remove-cluster#inputs
        api-token: ${{ inputs.replicated-api-token }}
        cluster-id: ${{ steps.prepare-replicated-cluster.outputs.cluster-id }}

    - name: Calculate Health
      if: always()
      id: health
      env:
        INTEGRATION_TEST_CONCLUSION: ${{ steps.integration-test.conclusion }}
        WORKFLOW_NAME: "Integration Test"
        GH_TOKEN: ${{ github.token }}
        LAST_TRIES: "4"
      shell: bash
      run: |
        set -euo pipefail

        export LAST_TRIES="$LAST_TRIES"

        # First, we retrieve the number of successes of the last (currently) 4 runs. Afterwards we
        # add 1 to the number of successes if this run succeeded. This ultimately represents the
        # number of successes in the last 5 runs, similar to what Jenkins does. This score is then
        # turned into an appropriate "weather" emoji and provided as an output to follow-up steps.
        SUCCESSES=$(gh run list --limit "$LAST_TRIES" --workflow "$WORKFLOW_NAME" --json conclusion | jq '[.[] | select(.conclusion == "success")] | length')
        [ "$CONCLUSION" == "success" ] && SUCCESSES=$(echo "$SUCCESSES+1" | bc)
        export SUCCESSES="$SUCCESSES"

        # TODO (@Techassi): Emit emojis for both Slack and GitHub
        echo "HEALTH=$(cat "${GITHUB_ACTION_PATH}/health" | envsubst | bc)" | tee -a "$GITHUB_OUTPUT"
